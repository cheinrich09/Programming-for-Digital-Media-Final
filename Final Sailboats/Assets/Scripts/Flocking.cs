using UnityEngine;
using System.Collections;
//including some .NET for dynamic arrays called List in C#
using System.Collections.Generic;

//directives to enforce that our parent Game Object required components
[RequireComponent(typeof(CharacterController))]
[RequireComponent(typeof(Steering))]

public class Flocking : MonoBehaviour
{
	// Each vehicle contains a CharacterController which
	// makes it easier to deal with the relationship between
	// movement initiated by the character and the forces
	// generated by contact with the terrain & other game objects.
	private CharacterController characterController;
	private Steering steering;
	private Ray[] feelers = new Ray[3];
	private FlockManager flockManager;
	public float wanderAngle = 0;
	public GameObject nearestFFPoint;

	// a unique identification number assigned by the flock manager 
	private int index = -1;
	public int Index {
		get { return index; }
		set { index = value; }
	}
	
	//movement variables
	private float gravity = 20.0f;
	private Vector3 moveDirection;

	//steering variable
	private Vector3 steeringForce;

	//list of nearby flockers
	private List<GameObject> nearFlockers = new List<GameObject> ();
	private List<float> nearFlockersDistances = new List<float> ();
	
	public void Start ()
	{
		//get component references
		characterController = gameObject.GetComponent<CharacterController> ();
		steering = gameObject.GetComponent<Steering> ();
		flockManager = FlockManager.Instance;
		nearestFFPoint = flockManager.FFPoints[0];
	}

	// get a reference to the manager's FlockManager component (script)
	public void setFlockManager (GameObject fManager)
	{
		flockManager = fManager.GetComponent<FlockManager> ();
	}
	
	private Vector3 FlowField()
	{
		//GameObject tempPoint = flockManager.FFPoints[0];
		for(int i = 0; i< flockManager.FFPoints.Length; i++)
		{
			if(Vector3.Distance(nearestFFPoint.transform.position, transform.position)>
				Vector3.Distance(flockManager.FFPoints[i].transform.position, transform.position))
			{
				nearestFFPoint = flockManager.FFPoints[i];

			}
			/*Debug.DrawLine(flockManager.FFPoints[i].transform.position, 
			flockManager.FFPoints[i].transform.position +  flockManager.FFPoints[i].transform.right*steering.Speed,
			Color.magenta);
			Debug.DrawLine(flockManager.FFPoints[i].transform.position, 
			flockManager.FFPoints[i].transform.position +  flockManager.FFPoints[i].transform.forward*steering.Speed,
			Color.red);*/
		}
		return steering.AlignTo(nearestFFPoint.transform.right);
	}
	
	private Vector3 Alignment ()
	{
		return steering.AlignTo (flockManager.FlockDirection);
	}

	
	private Vector3 Cohesion ()
	{
		return steering.Seek (flockManager.Centroid);
	}

	private Vector3 AvatarSeparation()
	{
		Vector3 dv = Vector3.zero;
		float dist = Vector3.Distance(flockManager.avatarBoat.transform.position, transform.position);
		if(dist < flockManager.separationDist 
				&& dist > 0)
			{
				dv += transform.position - flockManager.avatarBoat.transform.position;
				dv.Normalize();
				dv = dv * (1/dist);
			}
		//dv.y = 0; //only steer in the x/z plane
		return dv;
	}
	private Vector3 Separation ()
	{
		//empty our lists
		nearFlockers.Clear ();
		nearFlockersDistances.Clear ();
		
		Vector3 dv = Vector3.zero;
		Vector3 temp = Vector3.zero;
		float dist;
		//******* write this - it won't work as is ***********
		
		for (int i = 0; i < flockManager.numberOfFlockers; i++)
		{
			if(flockManager.getDistance(index, i) < flockManager.separationDist 
				&& flockManager.getDistance(i, index) > 0)
			{
				temp += transform.position - flockManager.Flockers[i].transform.position;
				temp.Normalize();
				temp = temp * (1/flockManager.getDistance(index, i));
				dv += temp;
			}
		}
		dv += AvatarSeparation();
		dv.y = 0; //only steer in the x/z plane
		return steering.AlignTo(dv);
	}

		

	private void ClampSteering ()
	{
		if (steeringForce.magnitude > steering.maxForce) {
			steeringForce.Normalize ();
			steeringForce *= steering.maxForce;
		}
	}
	
	
	// tether type containment - not very good!
	private Vector3 StayInBounds ( float radius, Vector3 center)
	{
		if(Vector3.Distance(transform.position, center) > radius)
			return steering.Seek (center);
		else
			return Vector3.zero;
		//return steering.Seek (center);
	}
	
	
	// Update is called once per frame
	public void Update ()
	{
		CalcSteeringForce ();
		ClampSteering ();
		
		moveDirection = transform.forward * steering.Speed;
		// movedirection equals velocity
		//add acceleration
		moveDirection += steeringForce * Time.deltaTime;
		//update speed
		steering.Speed = moveDirection.magnitude;
		if (steering.Speed != moveDirection.magnitude) {
			moveDirection = moveDirection.normalized * steering.Speed;
		}
		//orient transform
		if (moveDirection != Vector3.zero)
			transform.forward = moveDirection;
		
		// Apply gravity
		if(transform.position.y > flockManager.eHeight)
		{
			moveDirection.y -= gravity;
		}
		else if (transform.position.y < flockManager.eHeight)
		{
			Vector3 temp = new Vector3(transform.position.x, flockManager.eHeight, transform.position.z);
			transform.position = temp;
		}
		// the CharacterController moves us subject to physical constraints
		characterController.Move (moveDirection * Time.deltaTime);
	}

	public Vector3 Wander()
	{
		Vector3 dv = transform.forward * steering.Speed;
		dv.Normalize();
		dv *= flockManager.distanceToCircleCenter;
		Vector3 displace = new Vector3(0, 0, -1);
		displace *= flockManager.radiusOfCircle;
		
		wanderAngle += (Random.Range(0.0f, 1.0f) * flockManager.angleChange) - (flockManager.angleChange * 0.5f);
		
		displace.x = Mathf.Cos(wanderAngle) * displace.magnitude;
		displace.z = Mathf.Sin(wanderAngle) * displace.magnitude;
		
		return (dv + displace);
		
	}
	
	public Vector3 Containment(Ray gRay)
	{
		Vector3 dv = Vector3.zero;
		RaycastHit hit;
		if(flockManager.flockerTerrain.collider.Raycast(gRay, out hit, flockManager.containDist))
		{
			dv = Vector3.Project(hit.normal, transform.right);
            dv.y = 0;
            dv.Normalize();
            dv *= steering.maxSpeed;
            dv -= transform.forward * steering.Speed;
		}
		
		return dv;
	}
	
	public Vector3 UnAlignedAvoidance()
	{
		Vector3 dv = Vector3.zero;
		/*for (int i = 0; i < flockManager.numberOfFlockers; i++)
		{
			Vector3 forward = transform.forward * steering.Speed;
			forward.Normalize();
			Vector3 difference = flockManager.Flockers[i].transform.position +
				(flockManager.Flockers[i].transform.forward * steering.Speed);
			difference.Normalize();
			difference *=  flockManager.unAlignedDist;
			difference -= transform.position;
			Debug.DrawLine(transform.position, difference);
			float dotted = Vector3.Dot(forward, difference);
			if(dotted > 0)
			{
				Vector3 test = forward * flockManager.unAlignedDist;
				Vector3 proj = forward * dotted;
				float dist = (proj - difference).magnitude;
				if (dist < flockManager.Flockers[i].GetComponent<Dimensions>().Radius + GetComponent<Dimensions> ().Radius
					&& proj.magnitude < test.magnitude)
				{
					float rightDot = Vector3.Dot (difference, transform.right);
					if (rightDot > 0)
					{
						dv += transform.right * -steering.maxSpeed * flockManager.unAlignedDist / dist;
					}
					else
					{
						dv += transform.right * steering.maxSpeed * flockManager.unAlignedDist / dist;
					}
				
				}
			}
		}*/
		dv.y = 0;
		dv.Normalize();
		dv *= steering.maxSpeed;
		dv -= transform.forward * steering.Speed;
		
		//future position for this boat: transform.position + transform.forward * t;
		//future position for the given boat: gBoat.transform.position + gBoat.trasform.forward * t
		//distance between the 2 points -> d = SQRT(x^2 - z^2)
		//(transform.position - gBoat.transform.position) + (transform.forward - gBoat.transform.forward) * t;
		return dv;
	}
	
	private void CalcSteeringForce ()
	{
		feelers[0] = new Ray(transform.position, transform.forward.normalized);
		feelers[1] = new Ray(transform.position, (transform.forward+transform.right).normalized);
		feelers[2] = new Ray(transform.position, (transform.forward-transform.right).normalized);
		steeringForce = Vector3.zero;
		/*Debug.DrawLine(transform.position, transform.position+(transform.forward*steering.Speed));
				Debug.DrawLine(transform.position, transform.position+(transform.right*steering.Speed), Color.red);
		*/
		//steeringForce += transform.forward; //just to see if they move!
		for (int i = 0; i < 3; i++)
		{
			steeringForce += flockManager.containWt * Containment(feelers[i]);
		}
		steeringForce += flockManager.flowFieldWt * FlowField();
		steeringForce += flockManager.inBoundsWt * StayInBounds (100, new Vector3 (150, 0, 150));
		steeringForce += flockManager.alignmentWt * Alignment ();
		steeringForce += flockManager.cohesionWt * Cohesion ();
		steeringForce += flockManager.separationWt * Separation ();
		steeringForce += flockManager.wanderWt * Wander();
		steeringForce += flockManager.unAlignedWt * UnAlignedAvoidance();
		/*for (int i = 0; i < flockManager.Obstacles.Length; i++)
		{
			steeringForce += flockManager.avoidWt * steering.AvoidObstacle(flockManager.Obstacles[i], flockManager.avoidDist) ;	
		}*/
		//steeringForce+= flockManager.avoidWt * steering.AvoidObstacle(flockManager.avatarBoat.GetComponent<Avatar>().containedObject, flockManager.avoidDist);
	}
	
}